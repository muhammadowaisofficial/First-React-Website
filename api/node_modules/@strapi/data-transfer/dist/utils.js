"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapSchemasValues = exports.jsonDiffs = exports.collect = void 0;
const fp_1 = require("lodash/fp");
/**
 * Collect every entity in a Readable stream
 */
const collect = (stream) => {
    const chunks = [];
    return new Promise((resolve) => {
        stream.on('data', (chunk) => chunks.push(chunk));
        stream.on('end', () => {
            stream.destroy();
            resolve(chunks);
        });
    });
};
exports.collect = collect;
const createContext = () => ({ path: [] });
const jsonDiffs = (a, b, ctx = createContext()) => {
    const diffs = [];
    const { path } = ctx;
    // Define helpers
    const added = () => {
        diffs.push({ kind: 'added', path, type: bType, value: b });
        return diffs;
    };
    const deleted = () => {
        diffs.push({ kind: 'deleted', path, type: aType, value: a });
        return diffs;
    };
    const modified = () => {
        diffs.push({
            kind: 'modified',
            path,
            types: [aType, bType],
            values: [a, b],
        });
        return diffs;
    };
    const aType = typeof a;
    const bType = typeof b;
    if (aType === 'undefined') {
        return added();
    }
    if (bType === 'undefined') {
        return deleted();
    }
    if ((0, fp_1.isArray)(a) && (0, fp_1.isArray)(b)) {
        let k = 0;
        for (const [aItem, bItem] of (0, fp_1.zip)(a, b)) {
            const kCtx = { path: [...path, k.toString()] };
            const kDiffs = (0, exports.jsonDiffs)(aItem, bItem, kCtx);
            diffs.push(...kDiffs);
            k++;
        }
        return diffs;
    }
    if ((0, fp_1.isObject)(a) && (0, fp_1.isObject)(b)) {
        const keys = (0, fp_1.uniq)(Object.keys(a).concat(Object.keys(b)));
        for (const key of keys) {
            const aValue = a[key];
            const bValue = b[key];
            const nestedDiffs = (0, exports.jsonDiffs)(aValue, bValue, { path: [...path, key] });
            diffs.push(...nestedDiffs);
        }
        return diffs;
    }
    if (!(0, fp_1.isEqual)(a, b)) {
        modified();
    }
    return diffs;
};
exports.jsonDiffs = jsonDiffs;
const schemaSelectedKeys = [
    'collectionName',
    'info',
    'options',
    'pluginOptions',
    'attributes',
    'kind',
    'modelType',
    'modelName',
    'uid',
    'plugin',
    'globalId',
];
const mapSchemasValues = (schemas) => (0, fp_1.mapValues)((0, fp_1.pick)(schemaSelectedKeys), schemas);
exports.mapSchemasValues = mapSchemasValues;
//# sourceMappingURL=utils.js.map