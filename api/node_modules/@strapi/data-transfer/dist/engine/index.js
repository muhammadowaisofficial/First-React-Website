"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _TransferEngine_instances, _TransferEngine_metadata, _TransferEngine_transferProgress, _TransferEngine_progressStream, _TransferEngine_increaseTransferProgress, _TransferEngine_countRecorder, _TransferEngine_updateStage, _TransferEngine_assertStrapiVersionIntegrity, _TransferEngine_assertSchemasMatching, _TransferEngine_resolveProviderResource;
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTransferEngine = exports.VALID_STRATEGIES = void 0;
const stream_chain_1 = require("stream-chain");
const fp_1 = require("lodash/fp");
const semverDiff = require('semver/functions/diff');
const strategies_1 = __importDefault(require("../strategies"));
exports.VALID_STRATEGIES = ['restore', 'merge'];
class TransferEngine {
    constructor(sourceProvider, destinationProvider, options) {
        _TransferEngine_instances.add(this);
        _TransferEngine_metadata.set(this, {});
        _TransferEngine_transferProgress.set(this, {});
        // TODO: Type the stream chunks. Doesn't seem trivial, especially since PassThrough doesn't provide a PassThroughOptions type
        _TransferEngine_progressStream.set(this, new stream_chain_1.PassThrough({ objectMode: true }));
        _TransferEngine_countRecorder.set(this, (transferStage, aggregateKey) => {
            return new stream_chain_1.PassThrough({
                objectMode: true,
                transform: (data, _encoding, callback) => {
                    __classPrivateFieldGet(this, _TransferEngine_instances, "m", _TransferEngine_increaseTransferProgress).call(this, transferStage, data, aggregateKey);
                    __classPrivateFieldGet(this, _TransferEngine_updateStage, "f").call(this, 'progress', transferStage);
                    callback(null, data);
                },
            });
        });
        _TransferEngine_updateStage.set(this, (type, transferStage) => {
            __classPrivateFieldGet(this, _TransferEngine_progressStream, "f").emit(type, {
                data: __classPrivateFieldGet(this, _TransferEngine_transferProgress, "f"),
                stage: transferStage,
            });
        });
        if (sourceProvider.type !== 'source') {
            throw new Error("SourceProvider does not have type 'source'");
        }
        if (destinationProvider.type !== 'destination') {
            throw new Error("DestinationProvider does not have type 'destination'");
        }
        this.sourceProvider = sourceProvider;
        this.destinationProvider = destinationProvider;
        this.options = options;
    }
    get progress() {
        return {
            data: __classPrivateFieldGet(this, _TransferEngine_transferProgress, "f"),
            stream: __classPrivateFieldGet(this, _TransferEngine_progressStream, "f"),
        };
    }
    async init() {
        // Resolve providers' resource and store
        // them in the engine's internal state
        await __classPrivateFieldGet(this, _TransferEngine_instances, "m", _TransferEngine_resolveProviderResource).call(this);
        // Update the destination provider's source metadata
        const { source: sourceMetadata } = __classPrivateFieldGet(this, _TransferEngine_metadata, "f");
        if (sourceMetadata) {
            this.destinationProvider.setMetadata?.('source', sourceMetadata);
        }
    }
    async bootstrap() {
        await Promise.all([this.sourceProvider.bootstrap?.(), this.destinationProvider.bootstrap?.()]);
    }
    async close() {
        await Promise.all([this.sourceProvider.close?.(), this.destinationProvider.close?.()]);
    }
    async integrityCheck() {
        try {
            const sourceMetadata = await this.sourceProvider.getMetadata();
            const destinationMetadata = await this.destinationProvider.getMetadata();
            if (sourceMetadata && destinationMetadata) {
                __classPrivateFieldGet(this, _TransferEngine_instances, "m", _TransferEngine_assertStrapiVersionIntegrity).call(this, sourceMetadata?.strapi?.version, destinationMetadata?.strapi?.version);
            }
            const sourceSchemas = await this.sourceProvider.getSchemas?.();
            const destinationSchemas = await this.destinationProvider.getSchemas?.();
            if (sourceSchemas && destinationSchemas) {
                __classPrivateFieldGet(this, _TransferEngine_instances, "m", _TransferEngine_assertSchemasMatching).call(this, sourceSchemas, destinationSchemas);
            }
            return true;
        }
        catch (error) {
            return false;
        }
    }
    validateTransferOptions() {
        if (!exports.VALID_STRATEGIES.includes(this.options.strategy)) {
            throw new Error('Invalid stategy ' + this.options.strategy);
        }
    }
    async transfer() {
        try {
            this.validateTransferOptions();
            await this.bootstrap();
            await this.init();
            const isValidTransfer = await this.integrityCheck();
            if (!isValidTransfer) {
                throw new Error(`Unable to transfer the data between ${this.sourceProvider.name} and ${this.destinationProvider.name}.\nPlease refer to the log above for more information.`);
            }
            // Run the transfer stages
            await this.transferSchemas();
            await this.transferEntities();
            await this.transferMedia();
            await this.transferLinks();
            await this.transferConfiguration();
            // Gracefully close the providers
            await this.close();
        }
        catch (e) {
            // Rollback the destination provider if an exception is thrown during the transfer
            // Note: This will be configurable in the future
            await this.destinationProvider.rollback?.(e);
            throw e;
        }
        return {
            source: this.sourceProvider.results,
            destination: this.destinationProvider.results,
        };
    }
    async transferSchemas() {
        const stageName = 'schemas';
        const inStream = await this.sourceProvider.streamSchemas?.();
        if (!inStream) {
            return;
        }
        const outStream = await this.destinationProvider.getSchemasStream?.();
        if (!outStream) {
            return;
        }
        __classPrivateFieldGet(this, _TransferEngine_updateStage, "f").call(this, 'start', stageName);
        return new Promise((resolve, reject) => {
            inStream
                // Throw on error in the source
                .on('error', reject);
            outStream
                // Throw on error in the destination
                .on('error', reject)
                // Resolve the promise when the destination has finished reading all the data from the source
                .on('close', () => {
                __classPrivateFieldGet(this, _TransferEngine_updateStage, "f").call(this, 'complete', stageName);
                resolve();
            });
            inStream.pipe(__classPrivateFieldGet(this, _TransferEngine_countRecorder, "f").call(this, stageName)).pipe(outStream);
        });
    }
    async transferEntities() {
        const stageName = 'entities';
        const inStream = await this.sourceProvider.streamEntities?.();
        if (!inStream) {
            return;
        }
        const outStream = await this.destinationProvider.getEntitiesStream?.();
        if (!outStream) {
            return;
        }
        __classPrivateFieldGet(this, _TransferEngine_updateStage, "f").call(this, 'start', stageName);
        return new Promise((resolve, reject) => {
            inStream
                // Throw on error in the source
                .on('error', (e) => {
                reject(e);
            });
            outStream
                // Throw on error in the destination
                .on('error', (e) => {
                reject(e);
            })
                // Resolve the promise when the destination has finished reading all the data from the source
                .on('close', () => {
                __classPrivateFieldGet(this, _TransferEngine_updateStage, "f").call(this, 'complete', stageName);
                resolve();
            });
            inStream.pipe(__classPrivateFieldGet(this, _TransferEngine_countRecorder, "f").call(this, stageName, 'type')).pipe(outStream);
        });
    }
    async transferLinks() {
        const stageName = 'links';
        const inStream = await this.sourceProvider.streamLinks?.();
        if (!inStream) {
            return;
        }
        const outStream = await this.destinationProvider.getLinksStream?.();
        if (!outStream) {
            return;
        }
        __classPrivateFieldGet(this, _TransferEngine_updateStage, "f").call(this, 'start', 'links');
        return new Promise((resolve, reject) => {
            inStream
                // Throw on error in the source
                .on('error', reject);
            outStream
                // Throw on error in the destination
                .on('error', reject)
                // Resolve the promise when the destination has finished reading all the data from the source
                .on('close', () => {
                __classPrivateFieldGet(this, _TransferEngine_updateStage, "f").call(this, 'complete', stageName);
                resolve();
            });
            inStream.pipe(__classPrivateFieldGet(this, _TransferEngine_countRecorder, "f").call(this, stageName)).pipe(outStream);
        });
    }
    async transferMedia() {
        const stageName = 'media';
        __classPrivateFieldGet(this, _TransferEngine_updateStage, "f").call(this, 'start', stageName);
        console.warn('transferMedia not yet implemented');
        return new Promise((resolve) => (() => {
            __classPrivateFieldGet(this, _TransferEngine_updateStage, "f").call(this, 'complete', stageName);
            resolve();
        })());
    }
    async transferConfiguration() {
        const stageName = 'configuration';
        const inStream = await this.sourceProvider.streamConfiguration?.();
        if (!inStream) {
            return;
        }
        const outStream = await this.destinationProvider.getConfigurationStream?.();
        if (!outStream) {
            return;
        }
        __classPrivateFieldGet(this, _TransferEngine_updateStage, "f").call(this, 'start', stageName);
        return new Promise((resolve, reject) => {
            inStream
                // Throw on error in the source
                .on('error', reject);
            outStream
                // Throw on error in the destination
                .on('error', reject)
                // Resolve the promise when the destination has finished reading all the data from the source
                .on('close', () => {
                __classPrivateFieldGet(this, _TransferEngine_updateStage, "f").call(this, 'complete', stageName);
                resolve();
            });
            inStream.pipe(__classPrivateFieldGet(this, _TransferEngine_countRecorder, "f").call(this, stageName)).pipe(outStream);
        });
    }
}
_TransferEngine_metadata = new WeakMap(), _TransferEngine_transferProgress = new WeakMap(), _TransferEngine_progressStream = new WeakMap(), _TransferEngine_countRecorder = new WeakMap(), _TransferEngine_updateStage = new WeakMap(), _TransferEngine_instances = new WeakSet(), _TransferEngine_increaseTransferProgress = function _TransferEngine_increaseTransferProgress(transferStage, data, aggregateKey) {
    if (!__classPrivateFieldGet(this, _TransferEngine_transferProgress, "f")[transferStage]) {
        __classPrivateFieldGet(this, _TransferEngine_transferProgress, "f")[transferStage] = { count: 0, bytes: 0 };
    }
    __classPrivateFieldGet(this, _TransferEngine_transferProgress, "f")[transferStage].count += 1;
    const size = JSON.stringify(data).length;
    __classPrivateFieldGet(this, _TransferEngine_transferProgress, "f")[transferStage].bytes += size;
    if (aggregateKey && data && data[aggregateKey]) {
        const aggKeyValue = data[aggregateKey];
        if (!__classPrivateFieldGet(this, _TransferEngine_transferProgress, "f")[transferStage]['aggregates']) {
            __classPrivateFieldGet(this, _TransferEngine_transferProgress, "f")[transferStage].aggregates = {};
        }
        if (!(__classPrivateFieldGet(this, _TransferEngine_transferProgress, "f")[transferStage].aggregates &&
            __classPrivateFieldGet(this, _TransferEngine_transferProgress, "f")[transferStage].aggregates[aggKeyValue])) {
            __classPrivateFieldGet(this, _TransferEngine_transferProgress, "f")[transferStage].aggregates[aggKeyValue] = { count: 0, bytes: 0 };
        }
        __classPrivateFieldGet(this, _TransferEngine_transferProgress, "f")[transferStage].aggregates[aggKeyValue].count += 1;
        __classPrivateFieldGet(this, _TransferEngine_transferProgress, "f")[transferStage].aggregates[aggKeyValue].bytes += size;
    }
}, _TransferEngine_assertStrapiVersionIntegrity = function _TransferEngine_assertStrapiVersionIntegrity(sourceVersion, destinationVersion) {
    const strategy = this.options.versionMatching;
    if (!sourceVersion ||
        !destinationVersion ||
        strategy === 'ignore' ||
        destinationVersion === sourceVersion) {
        return;
    }
    let diff;
    try {
        diff = semverDiff(sourceVersion, destinationVersion);
    }
    catch (e) {
        throw new Error(`Strapi versions doesn't match (${strategy} check): ${sourceVersion} does not match with ${destinationVersion}`);
    }
    if (!diff) {
        return;
    }
    const validPatch = ['prelease', 'build'];
    const validMinor = [...validPatch, 'patch', 'prepatch'];
    const validMajor = [...validMinor, 'minor', 'preminor'];
    if (strategy === 'patch' && validPatch.includes(diff)) {
        return;
    }
    if (strategy === 'minor' && validMinor.includes(diff)) {
        return;
    }
    if (strategy === 'major' && validMajor.includes(diff)) {
        return;
    }
    throw new Error(`Strapi versions doesn't match (${strategy} check): ${sourceVersion} does not match with ${destinationVersion}`);
}, _TransferEngine_assertSchemasMatching = function _TransferEngine_assertSchemasMatching(sourceSchemas, destinationSchemas) {
    const strategy = this.options.schemasMatching || 'strict';
    const keys = (0, fp_1.uniq)(Object.keys(sourceSchemas).concat(Object.keys(destinationSchemas)));
    const diffs = {};
    keys.forEach((key) => {
        const sourceSchema = sourceSchemas[key];
        const destinationSchema = destinationSchemas[key];
        const schemaDiffs = (0, strategies_1.default)(sourceSchema, destinationSchema, strategy);
        if (schemaDiffs.length) {
            diffs[key] = schemaDiffs;
        }
    });
    if (!(0, fp_1.isEmpty)(diffs)) {
        throw new Error(`Import process failed because the project doesn't have a matching data structure 
        ${JSON.stringify(diffs, null, 2)}        
        `);
    }
}, _TransferEngine_resolveProviderResource = async function _TransferEngine_resolveProviderResource() {
    const sourceMetadata = await this.sourceProvider.getMetadata();
    const destinationMetadata = await this.destinationProvider.getMetadata();
    if (sourceMetadata) {
        __classPrivateFieldGet(this, _TransferEngine_metadata, "f").source = sourceMetadata;
    }
    if (destinationMetadata) {
        __classPrivateFieldGet(this, _TransferEngine_metadata, "f").destination = destinationMetadata;
    }
};
const createTransferEngine = (sourceProvider, destinationProvider, options) => {
    return new TransferEngine(sourceProvider, destinationProvider, options);
};
exports.createTransferEngine = createTransferEngine;
//# sourceMappingURL=index.js.map