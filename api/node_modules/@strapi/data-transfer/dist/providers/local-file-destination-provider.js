"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _LocalFileDestinationProvider_instances, _LocalFileDestinationProvider_providersMetadata, _LocalFileDestinationProvider_archive, _LocalFileDestinationProvider_archivePath_get, _LocalFileDestinationProvider_getDataTransformers, _LocalFileDestinationProvider_writeMetadata, _LocalFileDestinationProvider_getMetadataStream;
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLocalFileDestinationProvider = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const tar_stream_1 = __importDefault(require("tar-stream"));
const zlib_1 = __importDefault(require("zlib"));
const stream_1 = require("stream");
const Stringer_1 = require("stream-json/jsonl/Stringer");
const stream_chain_1 = require("stream-chain");
const encrypt_1 = require("../encryption/encrypt");
const createLocalFileDestinationProvider = (options) => {
    return new LocalFileDestinationProvider(options);
};
exports.createLocalFileDestinationProvider = createLocalFileDestinationProvider;
class LocalFileDestinationProvider {
    constructor(options) {
        _LocalFileDestinationProvider_instances.add(this);
        this.name = 'destination::local-file';
        this.type = 'destination';
        this.results = {};
        _LocalFileDestinationProvider_providersMetadata.set(this, {});
        _LocalFileDestinationProvider_archive.set(this, {});
        this.options = options;
    }
    setMetadata(target, metadata) {
        __classPrivateFieldGet(this, _LocalFileDestinationProvider_providersMetadata, "f")[target] = metadata;
        return this;
    }
    bootstrap() {
        const { compression, encryption } = this.options;
        if (encryption.enabled && !encryption.key) {
            throw new Error("Can't encrypt without a key");
        }
        __classPrivateFieldGet(this, _LocalFileDestinationProvider_archive, "f").stream = tar_stream_1.default.pack();
        const outStream = fs_extra_1.default.createWriteStream(__classPrivateFieldGet(this, _LocalFileDestinationProvider_instances, "a", _LocalFileDestinationProvider_archivePath_get));
        const archiveTransforms = [];
        if (compression.enabled) {
            archiveTransforms.push(zlib_1.default.createGzip());
        }
        if (encryption.enabled && encryption.key) {
            archiveTransforms.push((0, encrypt_1.createEncryptionCipher)(encryption.key));
        }
        __classPrivateFieldGet(this, _LocalFileDestinationProvider_archive, "f").pipeline = (0, stream_chain_1.chain)([__classPrivateFieldGet(this, _LocalFileDestinationProvider_archive, "f").stream, ...archiveTransforms, outStream]);
        this.results.file = { path: __classPrivateFieldGet(this, _LocalFileDestinationProvider_instances, "a", _LocalFileDestinationProvider_archivePath_get) };
    }
    async close() {
        const { stream, pipeline } = __classPrivateFieldGet(this, _LocalFileDestinationProvider_archive, "f");
        if (!stream) {
            return;
        }
        await __classPrivateFieldGet(this, _LocalFileDestinationProvider_instances, "m", _LocalFileDestinationProvider_writeMetadata).call(this);
        stream.finalize();
        if (pipeline && !pipeline.closed) {
            await new Promise((resolve, reject) => {
                pipeline.on('close', resolve).on('error', reject);
            });
        }
    }
    async rollback() {
        await this.close();
        fs_extra_1.default.rmSync(__classPrivateFieldGet(this, _LocalFileDestinationProvider_instances, "a", _LocalFileDestinationProvider_archivePath_get), { force: true });
    }
    getMetadata() {
        return null;
    }
    getSchemasStream() {
        if (!__classPrivateFieldGet(this, _LocalFileDestinationProvider_archive, "f").stream) {
            throw new Error('Archive stream is unavailable');
        }
        const filePathFactory = createFilePathFactory('schemas');
        const entryStream = createTarEntryStream(__classPrivateFieldGet(this, _LocalFileDestinationProvider_archive, "f").stream, filePathFactory, this.options.file.maxSize);
        return (0, stream_chain_1.chain)([(0, Stringer_1.stringer)(), entryStream]);
    }
    getEntitiesStream() {
        if (!__classPrivateFieldGet(this, _LocalFileDestinationProvider_archive, "f").stream) {
            throw new Error('Archive stream is unavailable');
        }
        const filePathFactory = createFilePathFactory('entities');
        const entryStream = createTarEntryStream(__classPrivateFieldGet(this, _LocalFileDestinationProvider_archive, "f").stream, filePathFactory, this.options.file.maxSize);
        return (0, stream_chain_1.chain)([(0, Stringer_1.stringer)(), entryStream]);
    }
    getLinksStream() {
        if (!__classPrivateFieldGet(this, _LocalFileDestinationProvider_archive, "f").stream) {
            throw new Error('Archive stream is unavailable');
        }
        const filePathFactory = createFilePathFactory('links');
        const entryStream = createTarEntryStream(__classPrivateFieldGet(this, _LocalFileDestinationProvider_archive, "f").stream, filePathFactory, this.options.file.maxSize);
        return (0, stream_chain_1.chain)([(0, Stringer_1.stringer)(), entryStream]);
    }
    getConfigurationStream() {
        if (!__classPrivateFieldGet(this, _LocalFileDestinationProvider_archive, "f").stream) {
            throw new Error('Archive stream is unavailable');
        }
        const filePathFactory = createFilePathFactory('configuration');
        const entryStream = createTarEntryStream(__classPrivateFieldGet(this, _LocalFileDestinationProvider_archive, "f").stream, filePathFactory, this.options.file.maxSize);
        return (0, stream_chain_1.chain)([(0, Stringer_1.stringer)(), entryStream]);
    }
}
_LocalFileDestinationProvider_providersMetadata = new WeakMap(), _LocalFileDestinationProvider_archive = new WeakMap(), _LocalFileDestinationProvider_instances = new WeakSet(), _LocalFileDestinationProvider_archivePath_get = function _LocalFileDestinationProvider_archivePath_get() {
    const { encryption, compression, file } = this.options;
    let path = `${file.path}.tar`;
    if (compression.enabled) {
        path += '.gz';
    }
    if (encryption.enabled) {
        path += '.enc';
    }
    return path;
}, _LocalFileDestinationProvider_getDataTransformers = function _LocalFileDestinationProvider_getDataTransformers(options = {}) {
    const { jsonl = true } = options;
    const transforms = [];
    if (jsonl) {
        // Convert to stringified JSON lines
        transforms.push((0, Stringer_1.stringer)());
    }
    return transforms;
}, _LocalFileDestinationProvider_writeMetadata = async function _LocalFileDestinationProvider_writeMetadata() {
    const metadata = __classPrivateFieldGet(this, _LocalFileDestinationProvider_providersMetadata, "f").source;
    if (metadata) {
        await new Promise((resolve) => {
            const outStream = __classPrivateFieldGet(this, _LocalFileDestinationProvider_instances, "m", _LocalFileDestinationProvider_getMetadataStream).call(this);
            const data = JSON.stringify(metadata, null, 2);
            stream_1.Readable.from(data).pipe(outStream).on('close', resolve);
        });
    }
}, _LocalFileDestinationProvider_getMetadataStream = function _LocalFileDestinationProvider_getMetadataStream() {
    const { stream } = __classPrivateFieldGet(this, _LocalFileDestinationProvider_archive, "f");
    if (!stream) {
        throw new Error('Archive stream is unavailable');
    }
    return createTarEntryStream(stream, () => 'metadata.json');
};
/**
 * Create a file path factory for a given path & prefix.
 * Upon being called, the factory will return a file path for a given index
 */
const createFilePathFactory = (type) => (fileIndex = 0) => {
    return path_1.default.join(
    // "{type}" directory
    type, 
    // "${type}_XXXXX.jsonl" file
    `${type}_${String(fileIndex).padStart(5, '0')}.jsonl`);
};
const createTarEntryStream = (archive, pathFactory, maxSize = 2.56e8) => {
    let fileIndex = 0;
    let buffer = '';
    const flush = async () => {
        if (!buffer) {
            return;
        }
        const name = pathFactory(fileIndex++);
        const size = buffer.length;
        await new Promise((resolve, reject) => {
            archive.entry({ name, size }, buffer, (err) => {
                if (err) {
                    reject(err);
                }
                resolve();
            });
        });
        buffer = '';
    };
    const push = (chunk) => {
        buffer += chunk;
    };
    return new stream_1.Writable({
        async destroy(err, callback) {
            await flush();
            callback(err);
        },
        async write(chunk, _encoding, callback) {
            const size = chunk.length;
            if (chunk.length > maxSize) {
                callback(new Error(`payload too large: ${chunk.length}>${maxSize}`));
                return;
            }
            if (buffer.length + size > maxSize) {
                await flush();
            }
            push(chunk);
            callback(null);
        },
    });
};
//# sourceMappingURL=local-file-destination-provider.js.map