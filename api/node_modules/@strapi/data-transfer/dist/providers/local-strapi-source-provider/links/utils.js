"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.linkBuilder = exports.getDeepPopulateQuery = exports.parseRelationLinks = exports.parseEntityLinks = void 0;
const fp_1 = require("lodash/fp");
// TODO: Fix any typings when we'll have better Strapi types
/**
 * Parse every links from an entity result (including nested components and dynamic zone levels)
 */
const parseEntityLinks = (entity, populate, schema, strapi) => {
    if (!entity) {
        return [];
    }
    if (Array.isArray(entity)) {
        return entity
            .map((item) => (0, exports.parseEntityLinks)(item, populate, schema, strapi))
            .reduce(fp_1.concat, [])
            .flat();
    }
    const { attributes } = schema;
    const links = [];
    for (const key of Object.keys(populate)) {
        const attribute = attributes[key];
        const value = entity[key];
        const subPopulate = populate[key];
        // Ignore nil values (relations, components or dynamic zones not set)
        if (!value) {
            continue;
        }
        // Components
        // Recurse to find relations
        if (attribute.type === 'component') {
            const componentSchema = strapi.components[attribute.component];
            const componentLinks = (0, exports.parseEntityLinks)(value, subPopulate.populate, componentSchema, strapi);
            links.push(...componentLinks);
        }
        // Dynamic Zones
        // We need to extract links from each items in the DZ's components
        if (attribute.type === 'dynamiczone') {
            const dzLinks = value
                .map(({ __component, ...item }) => (0, exports.parseEntityLinks)(item, subPopulate.populate, strapi.components[__component], strapi))
                .reduce((acc, links) => acc.concat(...links), []);
            links.push(...dzLinks);
        }
        // Relations
        // If it's a regular relation, extract the links but do not recurse further
        if (attribute.type === 'relation') {
            const relationLinks = (0, exports.parseRelationLinks)({ entity, fieldName: key, value, schema });
            links.push(...relationLinks);
        }
    }
    return links;
};
exports.parseEntityLinks = parseEntityLinks;
/**
 * Parse links contained in a relational attribute
 */
const parseRelationLinks = ({ entity, schema, fieldName, value }) => {
    const attribute = schema.attributes[fieldName];
    const { relation, target } = attribute;
    // Handle ToMany relations
    if (Array.isArray(value)) {
        return (value
            // Get links from value
            .map((item) => (0, exports.parseRelationLinks)({ entity, schema, fieldName, value: item }))
            // Flatten the results, to make sure we're dealing with the right data structure
            .flat()
            // Update the pos with the relation index in the collection
            .map((link, i) => (0, fp_1.set)('left.pos', i, link)));
    }
    const isMorphRelation = relation.startsWith('morph');
    const isCircularRelation = !isMorphRelation && target === schema.uid;
    const kind = isMorphRelation
        ? // Polymorphic relations
            'relation.morph'
        : isCircularRelation
            ? // Self referencing relations
                'relation.circular'
            : // Regular relations
                'relation.basic';
    const link = (0, exports.linkBuilder)(kind, relation)
        .left(schema.uid, entity.id, fieldName)
        .right(target, value.id, attribute.inversedBy).value;
    return link ? [link] : [];
};
exports.parseRelationLinks = parseRelationLinks;
/**
 * Get a deep populate query for a given schema
 * It will populate first level for relations and media as well as
 * first-level relations for nested components and dynamic zones' components
 */
const getDeepPopulateQuery = (schema, strapi) => {
    const populate = {};
    for (const [key, attribute] of Object.entries(schema.attributes)) {
        const setPopulateKey = (value) => {
            populate[key] = value;
        };
        // Owning side of a relation
        if (attribute.type === 'relation' && !attribute.mappedBy) {
            setPopulateKey({ fields: ['id'] });
        }
        // Media
        if (attribute.type === 'media') {
            setPopulateKey({ fields: ['id'] });
        }
        // Dynamic zone (nested structure)
        if (attribute.type === 'dynamiczone') {
            const subPopulate = {};
            for (const component of attribute.components) {
                const componentSchema = strapi.components[component];
                const componentPopulate = (0, exports.getDeepPopulateQuery)(componentSchema, strapi);
                // FIXME: Same problem as when trying to populate dynamic zones,
                // we don't have a way to discriminate components queries (which
                // can cause issue when components share same fields name)
                Object.assign(subPopulate, componentPopulate);
            }
            if (!(0, fp_1.isEmpty)(subPopulate)) {
                setPopulateKey({ fields: ['id'], populate: subPopulate });
            }
        }
        // Component (nested structure)
        if (attribute.type === 'component') {
            const componentSchema = strapi.components[attribute.component];
            const componentPopulate = (0, exports.getDeepPopulateQuery)(componentSchema, strapi);
            if (!(0, fp_1.isEmpty)(componentPopulate)) {
                setPopulateKey({ fields: ['id'], populate: componentPopulate });
            }
        }
    }
    return populate;
};
exports.getDeepPopulateQuery = getDeepPopulateQuery;
/**
 * Domain util to create a link
 * TODO: Move that to the domain layer when we'll update it
 */
const linkBuilder = (kind, relation) => {
    const link = {};
    link.kind = kind;
    link.relation = relation;
    return {
        left(type, ref, field, pos) {
            link.left = { type, ref, field, pos };
            return this;
        },
        right(type, ref, field) {
            link.right = { type, ref, field };
            return this;
        },
        get value() {
            return link.left && link.right ? link : null;
        },
    };
};
exports.linkBuilder = linkBuilder;
//# sourceMappingURL=utils.js.map